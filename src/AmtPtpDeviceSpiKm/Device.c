/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, AmtPtpDeviceSpiKmCreateDevice)
#endif

NTSTATUS
AmtPtpDeviceSpiKmCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
    WDF_OBJECT_ATTRIBUTES DeviceAttributes;
    PDEVICE_CONTEXT pDeviceContext;
    WDFDEVICE Device;
    NTSTATUS Status;

	WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;

    PAGED_CODE();

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! Entry"
	);

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "AmtPtpDeviceSpiKmCreateDevice Entry \n"));

	// Initialize Power Callback
	WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);

	// Initialize PNP power event callbacks
	pnpPowerCallbacks.EvtDevicePrepareHardware = AmtPtpEvtDevicePrepareHardware;
	pnpPowerCallbacks.EvtDeviceD0Entry = AmtPtpEvtDeviceD0Entry;
	pnpPowerCallbacks.EvtDeviceD0Exit = AmtPtpEvtDeviceD0Exit;
	WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

	// Create WDF device object
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&DeviceAttributes, DEVICE_CONTEXT);

    Status = WdfDeviceCreate(&DeviceInit, &DeviceAttributes, &Device);

    if (NT_SUCCESS(Status)) 
	{
        //
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. DeviceGetContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        //
        pDeviceContext = DeviceGetContext(Device);

		//
		// Put itself in
		//
		pDeviceContext->SpiDevice = Device;
		pDeviceContext->DelayedRequest = FALSE;

		//
		// Retrieve IO target.
		//
		pDeviceContext->SpiTrackpadIoTarget = WdfDeviceGetIoTarget(Device);
		if (pDeviceContext->SpiTrackpadIoTarget == NULL) 
		{
			Status = STATUS_INVALID_DEVICE_STATE;
			goto exit;
		}

		//
		// Initialize kernel event.
		//
		KeInitializeEvent(
			&pDeviceContext->PtpRequestRoutineEvent, 
			NotificationEvent, 
			TRUE
		);

		KeInitializeEvent(
			&pDeviceContext->PtpLoopRoutineEvent,
			NotificationEvent,
			TRUE
		);

        //
        // Create a device interface so that applications can find and talk
        // to us.
        //
        Status = WdfDeviceCreateDeviceInterface(
            Device,
            &GUID_DEVINTERFACE_AmtPtpDeviceSpiKm,
            NULL // ReferenceString
        );

        if (NT_SUCCESS(Status)) 
		{
            //
            // Initialize the I/O Package and any Queues
            //
            Status = AmtPtpDeviceSpiKmQueueInitialize(Device);
        }
    }

exit:
	KdPrintEx((
		DPFLTR_IHVDRIVER_ID, 
		DPFLTR_INFO_LEVEL, 
		"AmtPtpDeviceSpiKmCreateDevice Exit, Status = 0x%x \n",
		Status
	));

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! Exit, Status = %!STATUS!",
		Status
	);

    return Status;
}

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
AmtPtpEvtDevicePrepareHardware(
	_In_ WDFDEVICE Device,
	_In_ WDFCMRESLIST ResourceList,
	_In_ WDFCMRESLIST ResourceListTranslated
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	PDEVICE_CONTEXT pDeviceContext;

	WDF_MEMORY_DESCRIPTOR HidAttributeMemoryDescriptor;
	HID_DEVICE_ATTRIBUTES DeviceAttributes;
	
	const SPI_TRACKPAD_INFO* pTrackpadInfo;
	BOOLEAN DeviceFound = FALSE;

	WDFKEY ParamRegistryKey;
	DECLARE_CONST_UNICODE_STRING(DesiredReportTypeKey, L"DesiredReportType");
	ULONG DesiredReportTypeValue, Length, ValueType = 0;

	PAGED_CODE();
	UNREFERENCED_PARAMETER(ResourceList);
	UNREFERENCED_PARAMETER(ResourceListTranslated);

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! Entry"
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpEvtDevicePrepareHardware entry \n"
	));

	pDeviceContext = DeviceGetContext(Device);
	if (pDeviceContext == NULL)
	{
		Status = STATUS_INVALID_DEVICE_STATE;
		TraceEvents(
			TRACE_LEVEL_INFORMATION,
			TRACE_DRIVER,
			"%!FUNC! pDeviceContext == NULL"
		);

		goto exit;
	}

	// Request device attribute descriptor for self-identification.
	WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(
		&HidAttributeMemoryDescriptor,
		(PVOID) &DeviceAttributes,
		sizeof(DeviceAttributes)
	);

	Status = WdfIoTargetSendInternalIoctlSynchronously(
		pDeviceContext->SpiTrackpadIoTarget,
		NULL,
		IOCTL_HID_GET_DEVICE_ATTRIBUTES,
		NULL,
		&HidAttributeMemoryDescriptor,
		NULL,
		NULL
	);

	if (!NT_SUCCESS(Status))
	{
		KdPrintEx((
			DPFLTR_IHVDRIVER_ID,
			DPFLTR_INFO_LEVEL,
			"WdfIoTargetSendInternalIoctlSynchronously failed, status = 0x%x \n",
			Status
		));

		goto exit;
	}

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"Device Vendor ID: 0x%x, Product ID: 0x%x, Version: 0x%x \n",
		DeviceAttributes.VendorID,
		DeviceAttributes.ProductID,
		DeviceAttributes.VersionNumber
	));

	pDeviceContext->HidVendorID = DeviceAttributes.VendorID;
	pDeviceContext->HidProductID = DeviceAttributes.ProductID;
	pDeviceContext->HidVersionNumber = DeviceAttributes.VersionNumber;

	// Find proper metadata in HID registry
	for (pTrackpadInfo = SpiTrackpadConfigTable; pTrackpadInfo->VendorId; ++pTrackpadInfo)
	{
		if (pTrackpadInfo->VendorId == DeviceAttributes.VendorID &&
			pTrackpadInfo->ProductId == DeviceAttributes.ProductID)
		{
			pDeviceContext->TrackpadInfo.ProductId = pTrackpadInfo->ProductId;
			pDeviceContext->TrackpadInfo.VendorId = pTrackpadInfo->VendorId;
			pDeviceContext->TrackpadInfo.XMin = pTrackpadInfo->XMin;
			pDeviceContext->TrackpadInfo.XMax = pTrackpadInfo->XMax;
			pDeviceContext->TrackpadInfo.YMin = pTrackpadInfo->YMin;
			pDeviceContext->TrackpadInfo.YMax = pTrackpadInfo->YMax;

			DeviceFound = TRUE;
			break;
		}
	}

	if (!DeviceFound)
	{
		Status = STATUS_NOT_FOUND;
		goto exit;
	}

	// Check the desired report type.
	Status = WdfDriverOpenParametersRegistryKey(
		WdfDeviceGetDriver(Device),
		KEY_READ,
		WDF_NO_OBJECT_ATTRIBUTES,
		&ParamRegistryKey
	);

	if (NT_SUCCESS(Status))
	{
		Status = WdfRegistryQueryValue(
			ParamRegistryKey,
			&DesiredReportTypeKey,
			sizeof(ULONG),
			&DesiredReportTypeValue,
			&Length,
			&ValueType
		);

		if (NT_SUCCESS(Status))
		{
			switch (DesiredReportTypeValue)
			{
			case 0:
				pDeviceContext->ReportType = PrecisionTouchpad;
				break;
			case 1:
				pDeviceContext->ReportType = Touchscreen;
				break;
			default:
				Status = STATUS_INVALID_PARAMETER;
				break;
			}
		}

		WdfRegistryClose(ParamRegistryKey);
	}

	// We don't really care if that param read fails.
	Status = STATUS_SUCCESS;

exit:
	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpEvtDevicePrepareHardware exit, status = 0x%x \n",
		Status
	));

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! Exit, Status = %!STATUS!",
		Status
	);

	return Status;
}

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
AmtPtpEvtDeviceD0Entry(
	_In_ WDFDEVICE Device,
	_In_ WDF_POWER_DEVICE_STATE PreviousState
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	PDEVICE_CONTEXT pDeviceContext;

	PAGED_CODE();

	// Log status
	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! -->AmtPtpDeviceEvtDeviceD0Entry - coming from %s",
		DbgDevicePowerString(PreviousState)
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL, 
		"AmtPtpEvtDeviceD0Entry -->AmtPtpDeviceEvtDeviceD0Entry - coming from %s \n", 
		DbgDevicePowerString(PreviousState)
	));

	pDeviceContext = DeviceGetContext(Device);

	// Enable SPI trackpad
	Status = AmtPtpSpiSetState(
		Device,
		TRUE
	);

	if (!NT_SUCCESS(Status))
	{
		goto exit;
	}

	// Set flag
	pDeviceContext->DeviceReady = TRUE;
	pDeviceContext->DelayedRequest = TRUE;

	// Reset mapping
	for (UINT8 i = 0; i < MAPPING_MAX; i++)
	{
		pDeviceContext->PtpMapping[i].ContactID = -1;
		pDeviceContext->PtpMapping[i].OriginalX = -1;
		pDeviceContext->PtpMapping[i].OriginalY = -1;
	}

	// Set time
	KeQueryPerformanceCounter(
		&pDeviceContext->LastReportTime
	);

	// Start HID loop in a new thread
	Status = PsCreateSystemThread(
		&pDeviceContext->InputPollThreadHandle,
		(ACCESS_MASK)0,
		NULL,
		(HANDLE)0,
		NULL,
		AmtPtpSpiInputThreadRoutine,
		pDeviceContext
	);

	if (!NT_SUCCESS(Status))
	{
		KdPrintEx((
			DPFLTR_IHVDRIVER_ID,
			DPFLTR_INFO_LEVEL,
			"PsCreateSystemThread failed, status = 0x%x \n",
			Status
		));
	}

exit:
	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! <-- AmtPtpDeviceEvtDeviceD0Entry"
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpEvtDeviceD0Entry <-- AmtPtpDeviceEvtDeviceD0Entry \n"
	));

	return Status;
}

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
AmtPtpEvtDeviceD0Exit(
	_In_ WDFDEVICE Device,
	_In_ WDF_POWER_DEVICE_STATE TargetState
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	PDEVICE_CONTEXT pDeviceContext;
	WDFREQUEST RemainingRequest;

	PAGED_CODE();

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! -->AmtPtpDeviceEvtDeviceD0Exit - moving to %s",
		DbgDevicePowerString(TargetState)
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpEvtDeviceD0Exit -->AmtPtpDeviceEvtDeviceD0Exit - moving to %s \n",
		DbgDevicePowerString(TargetState)
	));

	pDeviceContext = DeviceGetContext(Device);

	// Set flag & it will stop HID read loop thread
	pDeviceContext->DeviceReady = FALSE;

	// Wait for signaled state
	KeWaitForSingleObject(
		&pDeviceContext->PtpRequestRoutineEvent,
		Executive,
		KernelMode,
		FALSE,
		NULL
	);

	KeWaitForSingleObject(
		&pDeviceContext->PtpLoopRoutineEvent,
		Executive,
		KernelMode,
		FALSE,
		NULL
	);

	// Clean outstanding requests
	while (Status == STATUS_SUCCESS)
	{
		Status = WdfIoQueueRetrieveNextRequest(
			pDeviceContext->HidIoQueue,
			&RemainingRequest
		);

		if (NT_SUCCESS(Status))
		{
			WdfRequestComplete(
				RemainingRequest,
				STATUS_CANCELLED
			);
		}
	}

	// Disable HID trackpad
	Status = AmtPtpSpiSetState(
		Device,
		FALSE
	);

	// Reset mapping
	for (UINT8 i = 0; i < MAPPING_MAX; i++)
	{
		pDeviceContext->PtpMapping[i].ContactID = -1;
		pDeviceContext->PtpMapping[i].OriginalX = -1;
		pDeviceContext->PtpMapping[i].OriginalY = -1;
	}

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! <--AmtPtpDeviceEvtDeviceD0Exit"
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpEvtDeviceD0Exit <-- AmtPtpDeviceEvtDeviceD0Exit Exit \n"
	));

	return Status;
}

_IRQL_requires_(PASSIVE_LEVEL)
PCHAR
DbgDevicePowerString(
	_In_ WDF_POWER_DEVICE_STATE Type
)
{
	switch (Type)
	{
	case WdfPowerDeviceInvalid:
		return "WdfPowerDeviceInvalid";
	case WdfPowerDeviceD0:
		return "WdfPowerDeviceD0";
	case WdfPowerDeviceD1:
		return "WdfPowerDeviceD1";
	case WdfPowerDeviceD2:
		return "WdfPowerDeviceD2";
	case WdfPowerDeviceD3:
		return "WdfPowerDeviceD3";
	case WdfPowerDeviceD3Final:
		return "WdfPowerDeviceD3Final";
	case WdfPowerDevicePrepareForHibernation:
		return "WdfPowerDevicePrepareForHibernation";
	case WdfPowerDeviceMaximum:
		return "WdfPowerDeviceMaximum";
	default:
		return "UnKnown Device Power State";
	}
}

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
AmtPtpSpiSetState(
	_In_ WDFDEVICE Device,
	_In_ BOOLEAN DesiredState
)
{
	NTSTATUS Status;
	PDEVICE_CONTEXT pDeviceContext;
	UCHAR HidPacketBuffer[HID_XFER_PACKET_SIZE];
	WDF_MEMORY_DESCRIPTOR HidMemoryDescriptor;
	PHID_XFER_PACKET pHidPacket;
	PSPI_SET_FEATURE pSpiSetStatus;

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpSpiSetState Entry \n"
	));

	pDeviceContext = DeviceGetContext(Device);
	if (pDeviceContext == NULL)
	{
		Status = STATUS_INVALID_DEVICE_STATE;
		TraceEvents(
			TRACE_LEVEL_INFORMATION,
			TRACE_DRIVER,
			"%!FUNC! pDeviceContext == NULL"
		);

		goto exit;
	}

	pHidPacket = (PHID_XFER_PACKET) &HidPacketBuffer;

	WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(
		&HidMemoryDescriptor,
		(PVOID) &HidPacketBuffer,
		HID_XFER_PACKET_SIZE
	);

	pHidPacket->reportId = HID_REPORTID_MOUSE;
	pHidPacket->reportBufferLen = sizeof(SPI_SET_FEATURE);
	pHidPacket->reportBuffer = (PUCHAR) pHidPacket + sizeof(HID_XFER_PACKET);
	pSpiSetStatus = (PSPI_SET_FEATURE) pHidPacket->reportBuffer;

	// SPI Bus, location 2
	pSpiSetStatus->BusLocation = 2;
	pSpiSetStatus->Status = DesiredState ? 1 : 0;

	// Will non-internal IOCTL work?
	Status = WdfIoTargetSendInternalIoctlSynchronously(
		pDeviceContext->SpiTrackpadIoTarget,
		NULL,
		IOCTL_HID_SET_FEATURE,
		&HidMemoryDescriptor,
		NULL,
		NULL,
		NULL
	);

	if (!NT_SUCCESS(Status))
	{
		TraceEvents(
			TRACE_LEVEL_ERROR,
			TRACE_DRIVER,
			"%!FUNC! WdfIoTargetSendIoctlSynchronously failed with %!STATUS!",
			Status
		);

		KdPrintEx((
			DPFLTR_IHVDRIVER_ID,
			DPFLTR_INFO_LEVEL,
			"WdfIoTargetSendIoctlSynchronously failed \n"
		));
	}
	else
	{
		TraceEvents(
			TRACE_LEVEL_INFORMATION,
			TRACE_DRIVER,
			"%!FUNC! Changed trackpad status to %d",
			DesiredState
		);

		KdPrintEx((
			DPFLTR_IHVDRIVER_ID,
			DPFLTR_INFO_LEVEL,
			"AmtPtpSpiSetState Changed trackpad status to %d \n",
			DesiredState
		));
	}

exit:
	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpSpiSetState Exit \n"
	));
	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! Exit, Status = %!STATUS!",
		Status
	);

	return Status;
}

void
AmtPtpSpiInputThreadRoutine(
	PVOID StartContext
)
{
	PDEVICE_CONTEXT pDeviceContext;
	LARGE_INTEGER WaitInterval;

	PAGED_CODE();

	// Sanity check for the thing
	if (StartContext == NULL) return;
	pDeviceContext = (PDEVICE_CONTEXT) StartContext;

	// Lock it up!
	KeClearEvent(
		&pDeviceContext->PtpLoopRoutineEvent
	);

	// Initialize wait interval
	// This is not likely to be triggered: set it to 10 ms
	WaitInterval.QuadPart = WDF_REL_TIMEOUT_IN_MS(10);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpSpiInputThreadRoutine: ready to loop. \n"
	));

	while (pDeviceContext->DeviceReady)
	{
		AmtPtpSpiInputRoutineWorker(pDeviceContext->SpiDevice);
		KeDelayExecutionThread(KernelMode, FALSE, &WaitInterval);
	}

	// Notify that we are safe to terminate
	KeSetEvent(
		&pDeviceContext->PtpLoopRoutineEvent,
		0,
		FALSE
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpSpiInputThreadRoutine: terminated. \n"
	));

	// Goodbye
	PsTerminateSystemThread(STATUS_SUCCESS);
}
